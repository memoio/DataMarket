# FileProof如何保障用户数据的可用性

[FileProof设计文档](http://132.232.87.203:8088/did/did-solidity/blob/master/DESIGN(FileProof).md)

&nbsp;

1. 文件存储证明需要达到什么效果？

2. 为什么节点必须要完整地存储用户数据来应对存储证明和响应挑战呢？

3. kzg多项式承诺应用到文件存储证明中有什么优点？

&nbsp;

## 1. 文件存储证明需要达到什么效果？

首先，针对问题1，文件存储证明需要达到什么效果？那我们就先考虑什么情况下需要用到文件存储证明。也就是根据场景得出需求。

&nbsp;

存储模式从原来的集中式存储发展到分布式存储，再到现在的云存储。集中式存储是指将数据存储在由一台或者多台主机组成的中心节点上。分布式存储是指设备之间通过拓扑网络来协调、调动存储的信息，是一种将数据存储在多台服务器上的技术。云存储是一种将数据存储在云端的 技术。这类存储模式不需要存储证明，因为它们的存储证明依赖于服务商的信誉值。中心化服务商控制着存储设备，是否正确存储数据完全由服务商决定。

&nbsp;

然而在近年发展起来的分散式云存储模式中，没有中心化服务商，数据随机存储在全网的存储节点上，无法仅仅凭借存储节点的口头保证就相信数据完整地存储在节点上，系统需要自动地及时发现节点故障，从而及时进行数据恢复，这样才能保障用户数据的可用性。

&nbsp;

因此，在分散式云存储模式下需要用到文件存储证明。目的是让存储节点自动定期地向系统证明数据存储的完整性，从而使得系统能够及时发现节点故障并进行数据修复，以此保障用户数据的可用性。

&nbsp;

所以，文件存储证明首先要达到的效果，也是最重要的效果，就是表明节点确实完整地存储着用户数据。其次，由于在分散式云存储中，依靠区块链的去中心化、不可篡改以及自动化执行特点来验证文件存储证明，而受限于当前链上交易大小限制和成本高（相较于不需要交易费）以及链tps有限的特点，文件存储证明也应达到低成本、高效率的效果。然后，不可能直接把文件发给验证方进行验证，第一是数据量太大，第二是破坏用户数据的私密性。

&nbsp;

## 2. 节点为什么必须完整地存储用户数据？

通过上述[FileProof设计文档](http://132.232.87.203:8088/did/did-solidity/blob/master/DESIGN(FileProof).md)能够知道，用户定期提交的证明`proof`依赖于每次生成的随机数`rnd`，需要将用户数据分割为32字节的`atoms`作为多项式的系数，计算多项式在`rnd`处的值，也就是`y`值。如果节点没有保存用户的完整数据，那么就无法得到多项式系数，更不可能计算出正确的`y`值，那么就无法提供正确的证明`proof`，在乐观验证阶段，节点就无法通过。

&nbsp;

当然，这是在乐观情况下，节点无法通过验证。如果节点存在欺诈行为，提供错误的聚合承诺值`Cn`，从而使得错误的证明`proof`也能够通过验证（`proof`和`Cn`配对成功）。在这种情况下，就需要欺诈证明了。任何其他节点发现聚合承诺值`Cn`有问题，都可以往链上提出质疑从而发起挑战，由于链上保存了用户数据真实的承诺值`Commitment`，所以经过计算，就能准确发现节点提交的聚合承诺值`Cn`是错误的，那么同样可以认为节点没有通过存储证明。

综上所述，节点不能够通过只保存用户数据的`Commitment`或者只存储部分数据来通过存储证明，节点必须完整地存储用户数据才可以通过存储证明。

&nbsp;

## 3.  kzg多项式在文件存储证明中有什么优势？

同样，通过[FileProof设计文档](http://132.232.87.203:8088/did/did-solidity/blob/master/DESIGN(FileProof).md)能够知道，kzg多项式承诺保证在存储证明的过程中，只有存储节点知道用户数据（当然，是经过分片和加密的数据），验证方和挑战方不需要知道用户数据，这样的设计思想完全保障了用户数据的私密性。

&nbsp;

kzg多项式承诺还支持批量证明，不论是验证一个文件还是几千上万个文件的存储证明，节点都只需要提交一次固定大小的存储证明`proof`，而且存储证明的数据量小，只有两个G1点，在bls12_381曲线中，G1点占用96字节（x，y各占用48字节），所以存储证明数据量只有192字节。这样就极大降低了存储证明的成本，并且具有良好的可扩展性。

&nbsp;

> 链上验证存储证明，需要进行一次G1乘法、两次G1加法、一次G2乘法、一次G2加法以及一次配对操作，大概需要1.3544ms，可忽略不计。通过geth预编译合约消耗gas计算，链上验证存储证明大约消耗253708gas（只是粗略计算，后续还需完整测试），根据当前GasPrice：43.57537882Gwei，ETH Price：\$2017.35计算（2023.11.20），需消耗约\$22.3。这个代价还是比较大的。后面需要找一个gas费用低一些、bls12_381预编译合约gas消耗少的链，从而降低代价。比如Arbitrum链，根据当前GasPrice：0.1Gwei计算，需消耗约\$0.05。

&nbsp;

节点获取存储证明需要运行若干次的G1乘法和加法运算，根据[Benchmarking pairing-friendly elliptic curves libraries - HackMD](https://hackmd.io/@gnark/eccbench)可知，单次加法运算大约消耗387ns，单次乘法运算大约消耗245ns，节点运行加法和乘法次数取决于要验证的用户数据大小，如果生成32GB数据的存储证明，那么大约就需要1小时的时间。这在当前的存储证明行业里，不难看出效率较高。
